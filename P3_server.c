/***********************************************
*
* @Purpose: Server side implementation of an RPC chat app
* @Author: Oscar Cubeles
* @Creation Date: 26/11/2022
* @Last Updated: 27/11/2022
*
************************************************/
#define _XOPEN_SOURCE 500
#include "P3.h"
#include <strings.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>


/***********************************************
*
* @Purpose: Server side implementation of the write chat method. Appends the specified string in the logs.txt file
* @Parameters: in: **argp: pointer containing the string to be appended in the logs.txt file
*              in: *rqstp: default struct generated by rpcgen command
* @Return: -
*
************************************************/
void *write_chat_1_svc(char **argp, struct svc_req *rqstp){
	static char * result;
	int fd;
	// Necessary free, if not done it crashes
	xdr_free((xdrproc_t)xdr_string, (char *)&result);

	// Opening and writting the chat in the server log text file
	fd = open("logs.txt", O_WRONLY | O_APPEND | O_CREAT, 0666);
	write(fd, *argp, strlen(*argp));
	close(fd);

	return (void *) &result;
}


 /***********************************************
 *
 * @Purpose: Server side implementation of the get chat method.
 *           Gets the last unread line of log.txt from the client pov.
 * @Parameters: in: *argp: integer containing the number of lines read by the client.
 *              in: *rqstp: default struct generated by rpcgen command
 * @Return: last unread string from the client.
 *
 ************************************************/
char **get_chat_1_svc(int *argp, struct svc_req *rqstp){
	static char *result;
	char buffer[1024];
	FILE *fp;
	int num_lines = 0;
	// Necessary free, if not done it crashes
	xdr_free((xdrproc_t)xdr_string, (char *)&result);

	// Getting the total number of lines of the log file
	if ((fp = popen("cat logs.txt | wc -l", "r")) == NULL) {
  	printf("Error. Server was unable to obtain the number of lines in the file.\n");
		exit(-1);
  }

	// Getting the output of the command to buffer
	bzero(buffer, sizeof(buffer));
	fgets(buffer, 1024, fp);
	pclose(fp);
	num_lines = atoi(buffer);

	// Just get the chat if the client has read less lines than the number of lines in the file
	if(*argp <= num_lines){
		// Just get the last unread line from the client pov.
		//If there are more lines, more calls to this method will be done from the client. (Not a problem)
		sprintf(buffer, "tail -n +%d logs.txt | head -n 1", (*argp));
		if ((fp = popen(buffer, "r")) == NULL) {
			printf("Error. Server was unable to get the last message.\n");
			exit(-1);
		}

		// Copying the last line of the logs.txt file in the *result variable
		bzero(buffer, sizeof(buffer));
		fgets(buffer, 1024, fp);
		pclose(fp);
		result = (char *)malloc(sizeof(char)*(strlen(buffer) + 1));
		bzero(result, strlen(buffer) + 1);
		strcpy(result, buffer);
	}
	return &result;
}
